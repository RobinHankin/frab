% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-


\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{amssymb}        % needed for \leqslant
\usepackage{amsmath}        % needed for cases
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage[numbers]{natbib}
\usepackage{doi}
\usepackage{wrapfig}
\usepackage{tikz-cd}
\usepackage{xcolor}

\title{Adding tables with the free Abelian group in R: introducing the {\tt frab} package}

%\date{September 9, 1985}	% Here you can change the date presented in the paper title
%\date{} 					% Or removing it

\author{ \href{https://orcid.org/0000-0001-5982-0415}{\includegraphics[width=0.03\textwidth]{orcid.pdf}\hspace{1mm}Robin K. S.~Hankin}\thanks{\href{https://academics.aut.ac.nz/robin.hankin}{work};  
\href{https://www.youtube.com/watch?v=JzCX3FqDIOc&list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB&ab_channel=TrinTragulaGeneralRelativity}{play}} \\
 Auckland University of Technology\\
	\texttt{hankin.robin@gmail.com} \\
}

% Uncomment to remove the date
%\date{}

% Uncomment to override  the `A preprint' in the header
%\renewcommand{\headeright}{Technical Report}
%\renewcommand{\undertitle}{Technical Report}


%%% Add PDF metadata to help others organize their library
%%% Once the PDF is generated, you can check the metadata with
%%% $ pdfinfo template.pdf
\hypersetup{
pdftitle={The free Abelian group in R},
pdfsubject={q-bio.NC, q-bio.QM},
pdfauthor={Robin K. S.~Hankin},
pdfkeywords={The free Abelian group, named vectors}
}

\begin{document}
\maketitle

\setlength{\intextsep}{0pt}
\begin{wrapfigure}{r}{0.2\textwidth}
  \begin{center}
\includegraphics[width=1in]{frab.png}
  \end{center}
\end{wrapfigure}


\begin{abstract}

  In this short article I introduce the {\tt frab} package which
  provides an alternative interpretation of named vectors in the R
  programming language; it is available on CRAN at\\
  \url{https://CRAN.R-project.org/package=frab}.  The underlying
  mathematical object is the free Abelian group.

\end{abstract}

\SweaveOpts{}


\section{Introduction}

The {\bf Free Abelian Group} is a direct sum of infinite cyclic
groups.  If these cyclic goups are generated by $\left\lbrace
x_i\colon i\in\mathcal{I}\right\rbrace$ for some (finite) index set
$\mathcal{I}$, then the Free Abelian group $F$ will be

$$F=\bigoplus_{i\in\mathcal{I}}\left\langle x_i\right\rangle.$$

From now on we assume that $\left|\mathcal{I}\right| =k < \infty$;
thus the elements of $F$ will be of the form

\begin{equation}\label{formal_form}
g=n_1x_1+n_2x_2+\cdots+n_kx_k
\end{equation}

where $k_i\in\mathbb{Z}$, $1\leqslant i\leqslant k$.  The group
operation (conventionally one uses additive notation) is then defined
by componentwise addition:

$$g=n_1x_1+n_2x_2+\cdots+n_kx_k$$
$$h=r_1x_1+r_2x_2+\cdots+r_kx_k$$

$$h+g=(n_1+r_1)x_1+(n_2+r_2)x_2+\cdots+(n_k+r_k)x_k$$

One can define $F$ formally by starting with a generating set
$X=\left\lbrace x_1,\ldots,x_k\right\rbrace$ of symbols and defining
$F$ as the set of all formal expressions of the form~\ref{formal_form}
under addition as defined above.	 

The Free Abelian group is an interesting and useful mathematical
object.  Here I show how it may be implemented in the R programming
language \citep{rcore2023}.  I also show how a slight natural
generalization (which is convenient in the context of numerical
techniques), may be incorporated.

\section{Package internals}

The package uses the {\tt STL map} class for efficiency.  This class
maps strings (symbols) to doubles; the declaration

\begin{verbatim}
typedef std::map <std::string, double> frab; 
\end{verbatim}

appears in the {\tt src/} package directory.  Such maps are limited
only by memory availability.

\section{The {\tt frab} package in use}

The {\tt frab} package associates a numerical value with each of a set
of arbitrary (character string) symbols.  This is accomplished using
the {\tt STL} {\tt map} class, a container that stores key-value pairs
and allows fast lookup and insertion based on the key.  Here we have
keys as character strings and values are double-precision numbers.

To use the package, it must first be installed and loaded:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=installfrab,eval=FALSE>>=
install.packages("frab")
<<label=loadfrab,eval=TRUE>>=
library("frab")
set.seed(0)
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt install.packages()} downloads packages from CRAN
\item Function {\tt library()} loads packages to the current R session
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

The package uses a single S4 class, {\tt frab}, for which a variety of
methods is defined.  There are several ways to create {\tt frab}
objects, but the most straightforward is to coerce a named vector
using the {\tt frab()} function:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frab_direct>>=
frab(c(z=2,y=7,x=1))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} takes a named vector as its single argument
\item It returns an object of class {\tt frab}
\item The elements of the returned {\tt frab} object are reordered; they
appear in an implementation-specific order
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Above, see how {\tt frab()} takes a named numeric vector and returns
an object of class {\tt frab}.  It takes the names of its argument,
possibly reordering them, and returns a {\tt frab} object.  Function
{\tt frab()} considers the names of the elements to be the primary
extraction and replacement mechanism.  If the argument has repeated
names, function {\tt frab()} sums them:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frab_show_addition>>=
frab(c(t=3,q=2,t=4,q=-1,p=6,a=3,t=5))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} coerces its argument, a named
vector, to an object of class {\tt frab}
\item Element {\tt t}  and {\tt t} are summed, with values $3+5=8$ and 
$3+4+5=12$ respectively
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Above we see that the entries for {\tt t} and {\tt q} are summed.
Zero entries are discarded:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frab_show_zero_discarded>>=
frab(c(pear=1,kiwi=0,fig=3,lime=2,fig=-3))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} coerces its argument, a named
vector, to an object of class {\tt frab}
\item Element {\tt kiwi} is discarded, having a zero value
\item Element {\tt fig} vanishes, its entries cancelling
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Above we see that zero entries are discarded, irrespective of whether
a zero is explicitly given, or repeated values cancel.  However, the
main motivation for using {\tt frab} objects is that they may be
added:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=showfrabaddition>>=
a <- frab(c(x=2,y=1,z=3))
b <- frab(c(y=3,x=3,u=1))
a+b
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt a} and {\tt b} are of class {\tt frab}
\item Their sum is defined in terms of the keys of the summands, not
position
\item Thus, {\tt a+b} has 5 ($=2+3$) for its {\tt x} entry and 4
($=1+3$) for its {\tt y} entry
\item {\tt a+b} has its entries in implementation-specific order, as per
   {\tt disordR} discipline
\item Also, note that {\tt a+b} has length
4, while {\tt a} and {\tt b} have length 3
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

\section{Extensions of {\tt frab} objects to floating-point values}

The {\tt frab} class is sufficiently flexible to incorporate
floating-point values, although one has to be a little careful with
numerical round-off errors:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=showfrabroundofferrors>>=
x <- frab(c(a=4,u=pi,p=exp(pi)))
y <- frab(c(p=-exp(pi)/3,u=-pi))
z <- frab(c(p=-exp(pi)*2/3))
x+y+z
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt x}, {\tt y} and {\tt z} are of class {\tt frab}
\item Their sum {\tt x+y+z} should have zero entries for {\tt u} and {\tt p}
\item We see the entry for {\tt u} vanishes\ldots
\item \ldots But the entry for {\tt p} is nonzero, being subject to (small)
    numerical roundoff error
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]


\section{The {\tt frab} package and {\tt disordR} discipline}

The {\tt frab} package conforms to disord
discipline~\cite{hankin2022_disordR}.  Here I present some discussion
of the motivation for this design decision.  Consider the following
short R session:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
\begin{Schunk}
\begin{Sinput}
(a <- frab(c(x=2,y=1,u=8,z=3,v=5)))
\end{Sinput}
\begin{Soutput}
A frab object with entries
u v x y z 
8 5 2 1 3 
\end{Soutput}
\begin{Sinput}
> a["x"]
\end{Sinput}
\begin{Soutput}
A frab object with entries
x 
2 
\end{Soutput}
\begin{Sinput}
> a[1]
\end{Sinput}
\begin{Soutput}
Error in .local(x, i, j = j, ..., drop):
      not implemented
> 
\end{Soutput}
\end{Schunk}
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt a} is a map from symbols to numeric values
\item The {\tt STL map} class stores value-key pairs in an undefined order
\item Thus, extracting the value for {\tt "x"} is fine,  but because the order is not
defind it makes no sense to extract the ``first" element
\item And attempting to do so results in a disord discipline error
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Observe that we cannot dispense with order of the values entirely,
because sometimes I am interested in the vector of keys, or their
values, in isolation.  If we want to work with the names or values of
a {\tt frab} object, then the {\tt disord} print methods are used:

<<label=frabnamesisolation>>=
a <- frab(c(x=2,y=1,z=3))
names(a)
values(a)
@

Above we see that {\tt names(a)} and {\tt values(a)} return {\tt
disord} objects, in this case with the same hash code which indicates
that the objects are consistent with one another in the sense of {\tt
disordR::consitent()}.  These objects may be displayed and
subsequently manipulated, subject to disord discipline:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frabnamereplace>>=
(a <- frab(c(x=2,y=1,z=3)))
names(a) <- toupper(names(a))
a
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item {\tt a} is a {\tt frab} object
\item {\tt names(a)} is a {\tt disord} object as above
\item Replacement methods are defined, in this case {\tt toupper()}
    returns a {\tt disord} object
\item The names of {\tt a} become their uppercase equivalents
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Again observe that there is no meaning to the operation ``extract the
first element of {\tt names(a)}", because the elements of {\tt
names(a)}, being a {\tt disord} object, are stored in an
implementation-specific order.  We may manipulate the values of a {\tt
frab} object, if we are careful to be consistent with disord
discipline.  The package includes a number of convenient replacement
idioms:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frabvaluemanipulate>>=
(a <- frab(c(x=2,y=-1,z=3,p=-4,u=20)))
values(a) <- values(a)^2
a
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item {\tt a} is a {\tt frab} object
\item We square the {\tt values()} of {\tt a} using the replacement method
\item And object {\tt a} is altered appropriately
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Further, we may use the {\tt disindex} class of the {\tt disordR}
package to replace certain values using standard square bracket
replacement idiom:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=frabvaluemanipulate2>>=
(a <- frab(c(x=2,y=-1,z=11,p=-4,u=20)))
a[a>10] <- 19
a
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item {\tt a} is a {\tt frab} object
\item We set any value exceeding 10 to 19
\item And object {\tt a} is altered appropriately
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]



\section{Higher-dimensional tables}

The ideas above have a natural generalization to multi-dimensional
tables.  The {\tt frab} package {\tt S4} class is {\tt sparsetable},
and this has arithmetic methods implemented.  We start with
three-dimensional tables (two-dimensional {\tt sparstable} objects
have a print method that coerces them to arrays before displaying, and
the general case is easier to understand).

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=threedeeexample>>=
abcd <- letters[1:4]
jj <- sample(abcd,99,repl=T,prob=1/(1:4)^2)
I <- matrix(jj,33,3)
head(I)
nrow(I)
(x <- sparsetable(I))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt abc} is just {\tt c("a","b","c")}, defined to save
horizontal space
\vspace{30mm}
\item Random matrix {\tt I} has elements a-d
\item It has 33 rows
\item Coercing {\tt I} to {\tt sparsetable} object {\tt x} shows the counts
of each type of row.
\item Object {\tt x} has 13 rows; not all $4^3=64$ possible row types
are represented.
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@

Standard extraction and replacement operations work as expected on {\tt sparsetable} object {\tt x}:


\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=standardextraction>>=
x["a","a","b"]
x[rbind(c("a","b","b"),c("a","b","c"))]
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Extraction can operate with the arguments sent separately\ldots
\vspace{3mm}
\item Or as a matrix.
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@


However, other more specialised extraction methods are also provided:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=disordextraction>>=
x[x>3]
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Extraction can operate with a disord object
\item Here we extract every element greater than 3
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@

Replacement methods are also defined:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=disordreplacement>>=
x[x==1] <- 0
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Replacement can operate with a disord object
\item Here we replace each element equal to 1 with zero
\item Only elements $>1$ remain
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@

Replacement methods can add new entries if needed:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=disordreplacementnew>>=
x["a","x","y"] <- 1000
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item The replacement operator can create new entries
\item Here we create a new entry corresponding to {\tt a x y} with value $1000$
\item The new entry is placed in its own implementation-specific
location, as per {\tt disordR} discipline
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@


\section{Two dimensional tables}

If a {\tt sparsetable} object has arity 2, it is coerced to matrix
form before printing.  Otherwise, the semantics are the same as for
any other {\tt sparsetable} object.

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=twodeetables>>=
(x <- rspar2(9))
(y <- rspar2(9))
x+y
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt rspar()} gives a random 2D sparse table
\vspace{25mm}
\item {\tt x} and {\tt y} are random  {\tt sparsetable} objects
\vspace{20mm}
\item Package idiom allows sparse tables to be added even if the tables are different sizes
\item The resulting sum is automatically resized to accommodate both
addends
\item Entries with nonzero values in both {\tt x} and {\tt y}
are correctly summed
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]
@



\appendix
\section{Appendix: Named vectors in R}

A {\em named vector} is a vector with a names attribute; they are a
convenient and useful feature of the R programming language (R Core
Team 2022).  Each element of a named vector is associated with a name
or label.  Objects of the {\tt frab} class bears some resemblance to
named vectors.  However, there are some profound differences:

\subsection{Uniqueness of names}

The names of a named vector are not necessarily unique, unlike those
of a {\tt frab} object.  This has consequences for extraction and
replacement operations.  Consider the following:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsextract>>=
(x <- c(a=7,b=4,a=3))
x["a"]
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is a named vector with three elements.  Both the
first and the third element are named {\tt "a"}
\item This is perfectly OK
\item Extracting element {\tt "a"} returns the {\em first} element
with this name (Technically, it returns a named numeric vector of
length 1)
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

(we note in passing that double square bracket extraction, as in {\tt
x[["a"]]}, returns the value of the first element with name {\tt a}.

\subsection{Replacement methods for named vectors}

Replacement methods for named vectors is also somewhat problematic:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsreplace>>=
(x <- c(b=7,a=4,b=3,c=5))
x["a"] <- 100
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is a named vector with four elements.  Both the
first and the third element are named {\tt "a"}
\item Replacing the element {\tt "a"} with 100 behaves as expected:
the element with name {\tt "a"} is returned
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

This might lead one to believe that replacement of multiple elements
would behave as expected.  But:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsreplace2>>=
x <- c(b=7,a=4,b=3,c=5)
x["b"] <- 100
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is as before
\item Replacing the elements (putatively) indexed with {\tt "b"} [of
which there are two] with {\tt 100} results in only one element
being replaced.
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

We may also use multiple names for the index in a replacement operation:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorreplacetwonames>>=
x <- c(a=7, b=4, a=3, c=5)
x[c("a","c")] <- c(100,101)
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is as before
\item Replacing the elements (putatively) indexed with {\tt
c("a","c")} with {\tt c(100,101)} replaces the first (but not the
second) of the {\tt "a"} elements, and the {\tt "c"} element, with the
replacement value
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

\subsection{Addition of named vectors}

Named vectors obey the usual algebraic relations for vectors, although
the details can be unexpected.  Firstly, if nontrivial recycling rules
are applied, the result retains only the names of the longer of the
two addends:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectoraddanothernamedvector>>=
(x <- c(a=7, b=4, a=3, c=5))
x + c(uu=100)
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is a standard named vector
\item Adding {\tt c(uu=100)} [a named vector of length 1] to {\tt x} changes the values but not the names of the result
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Now with {\tt x} and {\tt y} named vectors of the same length, there
are at least three plausible values that it might give, viz:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorplausible>>=
x <- c(a=5,b=3,c=4)
y <- c(b=4,c=2,a=3)
plausible1 <- c(a=9,b=5,c=7)
plausible2 <- c(b=9,c=5,a=7)
plausible1 <- c(a=8,b=7,c=6)
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt x} and {\tt y} are standard named vectors
\item Three plausible results: {\tt p1 p2 p3}
\item {\tt p1} adds elementwise and assigns names of {\tt x}
\item {\tt p2} adds elementwise and assigns names of {\tt y}
\item {\tt p3} adds namewise
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

A good case could be made for any of the plausible outcomes above.
However, in standard R idiom, adding two named vectors is equivalent
to stripping the names attribute, performing the addition, then
inserting the names as appropriate.  If the two addends are of equal
length, the names of the first one is given the the result:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectoraddbothways>>=
x <- c(a=1,b=2,c=3)
y <- c(c=4,b=1,a=1)
x+y
y+x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt x} and {\tt y} are  standard named vectors
\item {\tt x+y} and {\tt y+x} have the same values but different names
\item {\tt x+y} inherits the names of {\tt x}
\item {\tt y+x} inherits the names of {\tt y}
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

If the addends are of incompatible length, a warning is given:


\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
\begin{Schunk}
\begin{Sinput}
> x <- c(a=1,b=2,c=3)
> y <- c(c=4,b=1,a=1,p=4)
> x+y
\end{Sinput}
\begin{Soutput}
c b a p 
5 3 4 5 
Warning message:
In x + y : longer object length is not a
   multiple of shorter object length
> 
\end{Soutput}
\end{Schunk}
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt x} and {\tt y} are  standard named vectors
\item {\tt x+y} is calculated using standard recycling rules
\item A warning (and optionally an error) is given
\item Names are inherited from the longer of the two addends, here {\tt y}
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]


\section{Tables in R}

Objects of class {\tt table} are created by function {\tt
table::base()}.  Their behaviour is discussed here.  Suppose we have
three tables:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=tables123>>=
xl <- c("a","a","b","c","d","d","a")
yl <- c("a","a","b","d","d","d","e")
zl <- c("a","a","b","d","d","e","f")
x <- table(xl)
y <- table(yl)
z <- table(zl)
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt xl yl zl} are character vectors
\item They may be tabulated using {\tt table()}
\item Object {\tt x} is of class {\tt table}
\item Its entries are in alphabetical order
\item The internal structure of {\tt x} is that of an array with named dimensions
\item Objects {\tt y} and {\tt z} are similar
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

Can we ascribe any meaning to {\tt x+y}?  We attempt standard R semantics:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=tablesaddwrong>>=
x
y
x+y
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item The sum is defined here
\item No error or warning is given
\item The result is clearly incorrect: the entries for {\tt c,d,e}
should be $1+0=1$, $2+3=5$, and $0+1=1$ respectively
\item The result given by R is comparable to the result of adding named vectors
\end{itemize}
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]

The correct way to add such tables would be by concatenating their
respective data:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=tablesaddright>>=
x
y
table(c(xl,yl))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt xl,yl} are defined in the previous chunk
\item We may tabulate {\tt c(xl,yl)}
\item The resulting object in essence sums the named entries of the tables {\tt x,y}
\item For example, the entry for {\tt a} is $3+2=5$
\item This is a reasonable interpretation of ``{\tt x+y}"
\item Note that the result is length 5, and that of each table is 4
\end{itemize} 
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]


If we do not have access to {\tt xl} and {\tt yl} then the only way to
``add" {\tt x} and {\tt y} would be to reconstruct them:

\vphantom{f}\\[2\baselineskip]
\begin{minipage}[t]{0.49\textwidth}
<<label=tablesaddwithrep>>=
x
y
(xl_rec <- rep(names(x),times=x))
(yl_rec <- rep(names(y),times=y))
table(c(xl_rec,yl_rec))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Objects {\tt x,y} are unchanged
\item We may reconstruct {\tt xl} by using {\tt base::rep(...)} with
the {\tt times} argument to form {\tt xl\_rec}
\item Similarly for {\tt yl}
\item And simply tabulate the concatentation {\tt c(xl\_rec,yl\_rec)} to ``add" {\tt x} and {\tt y}
\item The resulting table correctly sums the entries with regard to their labels
\end{itemize} 
\color{black}
\end{minipage}
\vphantom{f}\\[2\baselineskip]


However, this is extremely inefficient, especially if the entries are
large.  And indeed this method will not work for negative or
non-integral entries, although it is sufficiently robust to
accommodate zero entries consistently.


\bibliographystyle{apalike}
\bibliography{frab}

\end{document}
