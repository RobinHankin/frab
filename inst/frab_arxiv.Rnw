% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-


\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{amssymb}        % needed for \leqslant
\usepackage{amsmath}        % needed for cases
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}		% Can be removed after putting your text content
\usepackage{graphicx}
\usepackage[numbers]{natbib}
\usepackage{doi}
\usepackage{wrapfig}
\usepackage{tikz-cd}
\usepackage{xcolor}

\title{The free Abelian group in R: the {\tt frab} package}

%\date{September 9, 1985}	% Here you can change the date presented in the paper title
%\date{} 					% Or removing it

\author{ \href{https://orcid.org/0000-0001-5982-0415}{\includegraphics[width=0.03\textwidth]{orcid.pdf}\hspace{1mm}Robin K. S.~Hankin}\thanks{\href{https://academics.aut.ac.nz/robin.hankin}{work};  
\href{https://www.youtube.com/watch?v=JzCX3FqDIOc&list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB&ab_channel=TrinTragulaGeneralRelativity}{play}} \\
 Auckland University of Technology\\
	\texttt{hankin.robin@gmail.com} \\
}

% Uncomment to remove the date
%\date{}

% Uncomment to override  the `A preprint' in the header
%\renewcommand{\headeright}{Technical Report}
%\renewcommand{\undertitle}{Technical Report}


%%% Add PDF metadata to help others organize their library
%%% Once the PDF is generated, you can check the metadata with
%%% $ pdfinfo template.pdf
\hypersetup{
pdftitle={The free Abelian group in R},
pdfsubject={q-bio.NC, q-bio.QM},
pdfauthor={Robin K. S.~Hankin},
pdfkeywords={The free Abelian group, named vectors}
}

\begin{document}
\maketitle

\setlength{\intextsep}{0pt}
\begin{wrapfigure}{r}{0.2\textwidth}
  \begin{center}
\includegraphics[width=1in]{frab.png}
  \end{center}
\end{wrapfigure}


\begin{abstract}

  In this short article I introduce the {\tt frab} package which
  provides an alternative interpretation of named vectors in the R
  programming language; it is available on CRAN at\\
  \url{https://CRAN.R-project.org/package=frab}.  The underlying
  mathematical object is the free Abelian group.

\end{abstract}

\SweaveOpts{}


\section{Introduction}

The {\bf Free Abelian Group} is a direct sum of infinite cyclic
groups.  If these cyclic goups are generated by $\left\lbrace
x_i\colon i\in\mathcal{I}\right\rbrace$ for some (finite) index set
$\mathcal{I}$, then the Free Abelian group $F$ will be

$$F=\bigoplus_{i\in\mathcal{I}}\left\langle x_i\right\rangle.$$

From now on we assume that $\left|\mathcal{I}\right| =k < \infty$;
thus the elements of $F$ will be of the form

\begin{equation}\label{formal_form}
g=n_1x_1+n_2x_2+\cdots+n_kx_k
\end{equation}

where $k_i\in\mathbb{Z}$, $1\leqslant i\leqslant k$.  The group
operation (conventionally one uses additive notation) is then defined
by componentwise addition:

$$g=n_1x_1+n_2x_2+\cdots+n_kx_k$$
$$h=r_1x_1+r_2x_2+\cdots+r_kx_k$$

$$h+g=(n_1+r_1)x_1+(n_2+r_2)x_2+\cdots+(n_k+r_k)x_k$$

One can define $F$ formally by starting with a generating set
$X=\left\lbrace x_1,\ldots,x_k\right\rbrace$ of symbols and defining
$F$ as the set of all formal expressions of the form~\ref{formal_form}
under addition as defined above.	 

The Free Abelian group is an interesting and useful mathematical
object.  Here I show how it may be implemented in the R programming
language \citep{rcore2023}.  I also show how a slight natural
generalization (which is convenient in the context of numerical
techniques), may be incorporated.

\section{Package internals}

The package uses the {\tt STL map} class for efficiency.  This class
maps strings (symbols) to doubles; the declaration

\begin{verbatim}
typedef std::map <std::string, double> frab; 
\end{verbatim}

appears in the {\tt src/} package directory.  Such maps are limited
only by memory availability.

\section{The {\tt frab} package in use}

The {\tt frab} package associates a numerical value with each of a set
of arbitrary (character string) symbols.  This is accomplished using
the {\tt STL} {\tt map} class, a container that stores key-value pairs
and allows fast lookup and insertion based on the key.  Here we have
keys as character strings and values are double-precision numbers.

To use the package, it must first be installed and loaded:

\begin{minipage}[t]{0.49\textwidth}
<<label=installfrab,eval=FALSE>>=
install.packages("frab")
<<label=loadfrab,eval=TRUE>>=
library("frab")
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt install.packages()} downloads packages from CRAN
\item Function {\tt library()} loads packages to the current R session
\end{itemize}
\color{black}
\end{minipage}

The package uses a single S4 class, {\tt frab}, for which a variety of
methods is defined.  There are several ways to create {\tt frab}
objects, but the most straightforward is to coerce a named vector
using the {\tt frab()} function:

\begin{minipage}[t]{0.49\textwidth}
<<label=frab_direct>>=
frab(c(z=2,y=7,x=1))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} takes a named vector as its single argument.
\item It returns an object of class {\tt frab}
\item The elements of the returned {\tt frab} object are reordered; they
appear in an implementation-specific order.
\end{itemize}
\color{black}
\end{minipage}

Above, see how {\tt frab()} takes a named numeric vector and returns
an object of class {\tt frab}.  It takes the names of its argument,
possibly reordering them, and returns a {\tt frab} object.  Function
{\tt frab()} considers the names of the elements to be the primary
extraction and replacement mechanism.  If the argument has repeated
names, function {\tt frab()} sums them:

\begin{minipage}[t]{0.49\textwidth}
<<label=frab_show_addition>>=
frab(c(t=3,q=2,t=4,q=-1,p=6,a=3,t=5))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} coerces its argument, a named
vector, to an object of class {\tt frab}
\item Element {\tt t}  and {\tt t} are summed, with values $3+5=8$ and 
$3+4+5=12$ respectively.
\end{itemize}
\color{black}
\end{minipage}

Above we see that the entries for {\tt t} and {\tt q} are summed.
Zero entries are discarded:

\begin{minipage}[t]{0.49\textwidth}
<<label=frab_show_zero_discarded>>=
frab(c(pear=1,kiwi=0,fig=3,lime=2,fig=-3))
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Function {\tt frab()} coerces its argument, a named
vector, to an object of class {\tt frab}
\item Element {\tt kiwi} is discarded, having a zero value
\item Element {\tt fig} vanishes, its entries cancelling
\end{itemize}
\color{black}
\end{minipage}


Above we see that zero entries are discarded, irrespective of whether
a zero is explicitly given, or repeated values cancel.  However, the
main motivation for using {\tt frab} objects is that they may be
added:


\begin{minipage}[t]{0.49\textwidth}
<<label=showfrabaddition>>=
a <- frab(c(x=2,y=1,z=3))
b <- frab(c(y=3,x=3,u=1))
a+b
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}\item Objects {\tt a} and {\tt b} are of class {\tt frab}.
\item Their sum is defined in terms of the keys of the summands, not
position.
\item Thus, {\tt a+b} has 5 ($=2+3$) for its {\tt x} entry and 4
($=1+3$) for its {\tt y} entry.
\item Also, note that {\tt a+b} has length
4, while {\tt a} and {\tt b} have length 3.
\end{itemize}
\color{black}
\end{minipage}

\section{Named vectors in R}

A {\em named vector} is a vector with a names attribute; they are a
convenient and useful feature of the R programming language (R Core
Team 2022).  Each element of a named vector is associated with a name
or label.  Objects of the {\tt frab} class bears some resemblance to
named vectors.  However, there are some profound differences:

\subsection{Uniqueness of names}

The names of a named vector are not necessarily unique, unlike those
of a {\tt frab} object.  This has consequences for extraction and
replacement operations.  Consider the following:

\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsextract>>=
(x <- c(a=7,b=4,a=3))
x["a"]
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is a named vector with three elements.  Both the
first and the third element are named {\tt "a"}.
\item This is perfectly OK.
\item Extracting element {\tt "a"} returns the {\em first} element
with this name (Technically, it returns a named numeric vector of
length 1).
\end{itemize}
\color{black}
\end{minipage}

(we note in passing that double square bracket extraction, as in {\tt
x[["a"]]}, returns the value of the first element with name {\tt a}.

\subsubsection{Replacement methods for named vectors}

Replacement methods for named vectors is also somewhat problematic:

\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsreplace>>=
(x <- c(b=7,a=4,b=3,c=5))
x["a"] <- 100
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is a named vector with four elements.  Both the
first and the third element are named {\tt "a"}.
\item Replacing the element {\tt "a"} with 100 behaves as expected:
the element with name {\tt "a"} is returned.
\end{itemize}
\color{black}
\end{minipage}


This might lead one to believe that replacement of multiple elements
would behave as expected.  But:

\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsreplace2>>=
x <- c(b=7,a=4,b=3,c=5)
x["b"] <- c(100,101)
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is as before.
\item Replacing the elements (putatively) indexed with {\tt "b"} [of
which there are two] with {\tt c(100,101)} results in only one element
being replaced.
\end{itemize}
\color{black}
\end{minipage}


We may also replace elements with multiple names:

\begin{minipage}[t]{0.49\textwidth}
<<label=namedvectorwithrepeatsreplace2>>=
x <- c(a=7, b=4, a=3, c=5)
x[c("a","c")] <- c(100,101)
x
@
\end{minipage}
\hfill
\vrule
\hfill
\begin{minipage}[t]{0.49\textwidth}
\vspace{-\baselineskip}
\color{violet}
\begin{itemize}
\item Object {\tt x} is as before.
\item Replacing the elements (putatively) indexed with {\tt
c("a","c")} with {\tt c(100,101)} replaces the first of the {\tt "a"}
elements, and the {\tt "c"} element, with the replacement value.
\end{itemize}
\color{black}
\end{minipage}


It allows
you to assign a name to each element, making it easier to refer to
specific values within the vector using their respective names.






Named vectors are a convenient and useful feature of the R programming language (R Core Team 2022). However, given the following two named vectors:

x <- c(a=1,b=2,c=3)
y <- c(c=4,b=1,a=1)
Given that x+y returns a named vector, there are at least two plausible values that it might give, viz:

c(a=5,b=3,c=4)

or

c(a=2,b=3,c=7).

In the first case the elements of x and y are added pairwise, and the names attribute is taken from the first of the addends. In the second, the names are considered to be primary and the value of each name in the sum is the sum of the values of that name of the addends. Note further that there is no good reason why the first answer could not be c(c=5,b=3,a=4), obtained by using the names attribute of y instead of x.
<<label=namedvector>>=
(a <- c(x=6,t=6,a=3))
@

Above, object {\tt a} has three elements, each of which is named.  We
may access




\bibliographystyle{apalike}
\bibliography{frab}

\end{document}
